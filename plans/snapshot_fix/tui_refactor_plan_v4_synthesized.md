# OpenHCS TUI Comprehensive Refactoring Plan (V4 - Synthesized)

**Date:** 2025-05-22

**Goal:** To refactor the OpenHCS TUI to align with the canonical mental model (as described in `tui_core_concepts.md`, `tui_final.md`, and `tui_refactor_implementation_plan_v3.md`), implementing a cleaner, more modular, and user-friendly interface. This plan incorporates the Command Pattern for UI actions and an interactive VFS-aware file browser for adding plates.

**Core Architectural Principles (Reiteration from existing plans):**
*   **Deferred Validation:** Validation of plate data occurs at explicit user triggers like "Init" or "Compile", not during initial input.
*   **Interactive "Add Plate" Dialog:** Uses `OpenHCS.FileManager` for path selection, initially focusing on `StorageBackend.DISK`, with a design allowing future VFS backend flexibility.
*   **Configuration via Defaults and "Edit" Dialogs:** Global and plate-specific configurations are managed through dedicated dialogs, employing Static Reflection for dynamic UI generation.
*   **Plate Status Symbols:** Clear visual indicators (`?`, `-`, `✓`, `✗`) in the `PlateManagerPane` to show the state of each plate/orchestrator.
*   **Plates as Orchestrators:** Each plate is managed by its own `PipelineOrchestrator` instance.
*   **Dynamic UI from Static Reflection:** UI for editing `FunctionStep` parameters (Step/Func views) and configurations is generated by introspecting underlying Python objects and `FUNC_REGISTRY`.
*   **Centralized `storage_registry`:** A single, shared `storage_registry` instance is used, from which `FileManager` instances are created.
*   **Asynchronous Operations & `TUIState.notify`:** All potentially blocking operations are asynchronous, and inter-component communication primarily flows through `TUIState.notify` calls, which must be `async` and `await`ed.
*   **Command Pattern for UI Actions:** All actions triggered by user interaction (menu items, buttons) are encapsulated in `Command` objects.
*   **1:1 API Semantic Reflection in TUI:** The TUI's structure and interaction model directly mirror the underlying OpenHCS core API constructs and semantics.

---

## High-Level Target Architecture

```mermaid
graph TD
    App[OpenHCSTUILauncher] --> TUI[OpenHCSTUI]

    TUI --> TopBar[TopBar (MenuBar)]
    TUI --> TitlesBar[2ndBar (Titles)]
    TUI --> ContextButtonsBar[3rdBar (Contextual Buttons)]
    TUI --> MainPanes[HSplit: PlateMgr | PipelineEditor]
    TUI --> StatusBarPane[BottomBar (StatusBar)]

    TopBar -- triggers --> TopBar_Commands[ShowGlobalSettingsCmd, ShowHelpCmd]
    ContextButtonsBar -- triggers --> PlateMgr_Commands[AddPlateCmd, DelPlateCmd, EditPlateCfgCmd, InitPlateCmd, CompilePlateCmd, RunPlateCmd]
    ContextButtonsBar -- triggers --> PipelineEditor_Commands[AddStepCmd, DelStepCmd, EditStepCmd, LoadPipelineCmd, SavePipelineCmd]

    subgraph CommandsLayer [openhcs.tui.commands]
        TopBar_Commands
        PlateMgr_Commands
        PipelineEditor_Commands
        DualEditor_Commands[SwitchDualEditorViewCmd, SaveDualEditorCmd, CloseDualEditorCmd, LoadStepParamsCmd, SaveStepParamsCmd, LoadFuncPatternCmd, SaveFuncPatternCmd, EditPatternInVimCmd]
        Dialog_Commands[SaveGlobalConfigCmd, SavePlateConfigCmd, CancelDialogCmd]
    end

    CommandsLayer -- interact with --> TUIState[TUIState]
    CommandsLayer -- interact with --> CoreAdapters[TUI Services / Core API Adapters]
    CoreAdapters --> CoreServices[openhcs.core (Orchestrator, Config, FileManager, Steps, FuncRegistry)]


    MainPanes --> PMPane[PlateManagerPane]
    MainPanes --> PEPane[PipelineEditorPane]
    
    subgraph "Left Main Pane Content (Dynamic)"
        direction LR
        PMPane
        DualEditor[DualStepFuncEditorPane]
    end
    
    PEPane -- EditStepCmd triggers state change --> EditorSwitcher{TUIState: editing_step_config}
    EditorSwitcher -- true --> DualEditor
    DualEditor -- CloseDualEditorCmd triggers state change --> EditorSwitcher
    EditorSwitcher -- false --> PMPane

    TUI -. uses .-> TUIState
    PMPane -. uses/observes .-> TUIState
    PEPane -. uses/observes .-> TUIState
    DualEditor -. uses/observes .-> TUIState
    TopBar -. uses .-> TUIState
    StatusBarPane -. uses/observes .-> TUIState

    AddPlateCmd -- shows --> AddPlateDialog[Interactive AddPlateDialog (uses FileManager)]
    EditPlateCfgCmd -- shows --> PlateConfigDialog[PlateConfigEditorDialog (Static Reflection)]
    ShowGlobalSettingsCmd -- shows --> GlobalSettingsDialog[GlobalSettingsEditorDialog (Static Reflection)]
    
    InitPlateCmd -- uses --> OrchestratorUser[PipelineOrchestrator for selected plate]
    CompilePlateCmd -- uses --> OrchestratorUser
    RunPlateCmd -- uses --> OrchestratorUser

    App -- Manages --> AllOrchestrators[Dict of PipelineOrchestrators]
    OrchestratorUser -- uses --> GlobalCfg[GlobalPipelineConfig]
    OrchestratorUser -- uses --> PlateCfg[PlateSpecificConfig (optional)]
    
    DualEditor -- Edits --> FuncStep[FunctionStep object]
    DualEditor -- uses --> FuncRegistryRef[FUNC_REGISTRY for Func Menu]
    DualEditor -- uses --> AbstractStepRef[AbstractStep params for Step Menu]
```

---

## Phase 1: Core Layout, Command Infrastructure, and Foundational Component Adjustments

**Objective:** Establish the new 3-bar TUI layout, set up the Command Pattern infrastructure, refactor `MenuBar` and contextual button handlers to use Commands, and integrate the button containers from `PlateManagerPane` and `PipelineEditorPane`. Dismantle `ActionMenuPane`.

**1.1. Define Command Infrastructure**
    *   **Action:** Create `openhcs/tui/commands.py`.
    *   **Action:** Define a base `Command` protocol/ABC:
        ```python
        from typing import Protocol, Any
        from openhcs.tui.tui_architecture import TUIState # Forward reference if needed
        from openhcs.core.context.processing_context import ProcessingContext

        class Command(Protocol):
            async def execute(self, state: TUIState, context: ProcessingContext, **kwargs: Any) -> None: ...
            def can_execute(self, state: TUIState) -> bool: return True # Default
        ```
    *   **Action:** (Optional for now) Consider a `CommandRegistry` if dynamic command discovery/instantiation is needed later. For now, commands can be directly instantiated by UI event handlers.

**1.2. Refactor `OpenHCSTUI` Layout ([`openhcs/tui/tui_architecture.py`](openhcs/tui/tui_architecture.py:1))**
    *   **Action:** Modify `OpenHCSTUI._create_root_container()` to implement the 3-bar header layout:
        1.  **Top Bar (1st):** `self.menu_bar.container` (instance of `ActualMenuBar`).
        2.  **Titles Bar (2nd):** An `HSplit` with two `Frame(Label(...))` for "1 Plate Manager" and "2 Pipeline Editor". Height = 1.
        3.  **Contextual Buttons Bar (3rd):** An `HSplit` containing two `DynamicContainer`s.
            *   Left `DynamicContainer`: Returns `self.plate_manager.get_buttons_container()` if `self.plate_manager` exists, else a placeholder.
            *   Right `DynamicContainer`: Returns `self.step_viewer.get_buttons_container()` (assuming `step_viewer` is `PipelineEditorPane`) if it exists, else a placeholder. Height = 1.
        4.  **Main Panes:** An `HSplit` (changed from `VSplit`) containing `self._get_left_pane()` and `self._get_step_viewer()`.
        5.  **Bottom Bar:** `self.status_bar.container`.
    *   **Action:** Remove instantiation and usage of `ActionMenuPane` from `OpenHCSTUI._validate_components_present()` and `_create_root_container()`. (Ref: V3 Plan 1.1)

**1.3. Refactor Top `MenuBar` to use Commands ([`openhcs/tui/menu_bar.py`](openhcs/tui/menu_bar.py:1))**
    *   **Action:** In `openhcs/tui/commands.py`, create:
        *   `ShowGlobalSettingsDialogCommand(Command)`: Logic to show `GlobalSettingsEditorDialog`.
        *   `ShowHelpCommand(Command)`: Logic to show a help dialog/message.
    *   **Action:** Modify `MenuBar`'s initialization or menu structure loading:
        *   Menu items for "Global Settings" and "Help" will be associated with instances of these commands.
        *   The handlers for these menu items will call `command.execute(self.state, self.context)`.
        *   Remove old `_on_settings`, `_on_documentation`, `_on_about`, `_on_keyboard_shortcuts` methods if their functionality is covered or re-implemented via commands/new dialogs. (Focus on `Global Settings` and `Help` for now as per `tui_final.md` top bar).

**1.4. Adapt `PlateManagerPane` & Implement Contextual Button Commands ([`openhcs/tui/plate_manager_core.py`](openhcs/tui/plate_manager_core.py:1))**
    *   **Action:** In `openhcs/tui/commands.py`, create command classes:
        *   `ShowAddPlateDialogCommand(Command)`
        *   `DeleteSelectedPlatesCommand(Command)`
        *   `ShowEditPlateConfigDialogCommand(Command)`
        *   `InitializePlatesCommand(Command)`
        *   `CompilePlatesCommand(Command)`
        *   `RunPlatesCommand(Command)`
    *   **Action:** In `PlateManagerPane._initialize_ui()` (or similar method creating buttons):
        *   Button handlers for "add", "del", "edit", "init", "compile", "run" will instantiate and `await get_app().create_background_task(command.execute(self.state, self.context))`.
        *   Commands will encapsulate logic previously in `ActionMenuPane` or `PlateManagerPane` handlers. E.g., `InitializePlatesCommand.execute` will iterate selected plates from `self.state.selected_plates_or_focused_plate`, get their orchestrators, and call `orchestrator.initialize()`, handling errors and notifying `TUIState`.
    *   **Action:** Ensure `get_buttons_container()` returns the `HSplit` of these buttons.
    *   **Action:** Update `_format_plate_list()` to render new status symbols (`?`, `-`, `✓`, `✗`) and `^/v` reordering symbols.
    *   **Action:** Implement plate reordering logic in `_move_plate_up()` / `_move_plate_down()` and connect to keybindings or new commands if buttons are added for this.

**1.5. Adapt `PipelineEditorPane` (formerly `StepViewerPane`) & Implement Contextual Button Commands ([`openhcs/tui/step_viewer.py`](openhcs/tui/step_viewer.py:1))**
    *   **Action:** In `openhcs/tui/commands.py`, create command classes:
        *   `AddStepCommand(Command)`
        *   `DeleteSelectedStepsCommand(Command)`
        *   `ShowEditStepDialogCommand(Command)` (triggers `DualStepFuncEditorPane` via `TUIState`)
        *   `LoadPipelineCommand(Command)`
        *   `SavePipelineCommand(Command)`
    *   **Action:** In `PipelineEditorPane.setup()` (or similar method creating buttons):
        *   Button handlers for "add", "del", "edit", "load", "save" will instantiate and execute these commands.
        *   Commands will interact with `self.state.active_orchestrator.pipeline_definition`.
    *   **Action:** Ensure `get_buttons_container()` returns the `HSplit` of these buttons.
    *   **Action:** Update `_format_step_list()` for `^/v` reordering symbols. Ensure step reordering logic is functional.

**1.6. Dismantle `ActionMenuPane` ([`openhcs/tui/action_menu_pane.py`](openhcs/tui/action_menu_pane.py:1))**
    *   **Action:** After all logic is migrated to Command classes, delete `action_menu_pane.py`.
    *   **Action:** Remove all import statements and references to `ActionMenuPane` from other TUI files.

---

## Phase 2: Implement Interactive "Add Plate" Flow (VFS-Aware Browser)

**Objective:** Replace the `TextArea`-based "Add Plate" dialog with an interactive browser using `OpenHCS.FileManager` (initially for `StorageBackend.DISK`), triggered by `ShowAddPlateDialogCommand`.

**2.1. Investigate/Select/Build `prompt_toolkit`-native Interactive Directory Browser**
    *   **Action:** Execute the `ptpython` file browser investigation plan (as previously discussed). This involves examining `ptpython`'s source code to identify its browser component, assess its modularity, and determine if it can be adapted to use `OpenHCS.FileManager`.
    *   **Action:** If `ptpython`'s browser is not easily reusable:
        *   Briefly search for other existing `prompt_toolkit`-compatible directory browser widgets.
        *   If no suitable existing widget is found, make a decision:
            *   **Option A (Preferred for V3 scope):** Implement a simplified `prompt_toolkit`-native directory browser. It should list directory contents (from `FileManager.listdir(path, StorageBackend.DISK)`), allow navigation (up/down directories, select), and return the selected path. Multi-select can be deferred if too complex initially for this custom widget.
            *   **Option B (Fallback):** Revert to the `TextArea`-based input as defined in the current `PlateDialogManager` if a custom interactive browser is deemed out of scope for V3. Log interactive browser as high-priority future work.
    *   **Decision Point & Documentation:** Document the chosen browser widget/approach and the rationale. For the rest of this plan, we'll assume a `prompt_toolkit`-native interactive browser widget (`InteractiveDirBrowserWidget`) is chosen or built.

**2.2. Implement/Adapt `InteractiveDirBrowserWidget` to use `OpenHCS.FileManager`**
    *   **Action:** The `InteractiveDirBrowserWidget` must:
        *   Accept an `OpenHCS.FileManager` instance and an initial path.
        *   Use `file_manager.listdir(current_path, StorageBackend.DISK)` and `file_manager.isdir(entry_path, StorageBackend.DISK)` to display contents.
        *   Handle navigation (up, down, enter directory).
        *   Provide a mechanism to select one or more directories.
        *   Expose a method to get the selected path(s).
    *   **Action:** Design for future VFS backend selection: the widget should internally be capable of taking a `backend_enum` to pass to `FileManager` calls, even if `StorageBackend.DISK` is hardcoded for now.

**2.3. Update `PlateDialogManager` ([`openhcs/tui/dialogs/plate_dialog_manager.py`](openhcs/tui/dialogs/plate_dialog_manager.py:1))**
    *   **Action:** Modify `_create_file_browser_dialog()` (or rename to `_create_add_plate_dialog()`):
        *   Remove the `TextArea` and `ErrorBanner`.
        *   Instantiate and embed the `InteractiveDirBrowserWidget`.
        *   The dialog's "OK" button handler will retrieve selected path(s) from the `InteractiveDirBrowserWidget`.
    *   **Action:** The `ShowAddPlateDialogCommand` (from Phase 1.4) will be responsible for:
        *   Instantiating `PlateDialogManager`.
        *   Calling its method to show this dialog (e.g., `dialog_manager.show_add_plate_dialog(file_manager=self.context.filemanager)`).
        *   Receiving the selected paths from the dialog.
        *   If paths are received, proceeding to create orchestrators (this logic might be part of the command itself or delegated).

**2.4. Update Orchestrator Creation Logic (within `ShowAddPlateDialogCommand` or delegated service)**
    *   **Action:** On receiving path(s) from the dialog:
        *   For each path, create a `PipelineOrchestrator` instance using `self.state.global_config` and the provided path (which is a disk path for now).
        *   Add the new plate data (name, path, status `?`, orchestrator instance) to `PlateManagerPane.plates` (this might be done by `PlateManagerPane` itself in response to an event).
        *   Notify `TUIState.notify('plate_orchestrator_added', {'plate_id': ..., 'orchestrator': ..., 'path': ...})`.
        *   Notify `TUIState.set_selected_plate(...)` for the first newly added plate.

**2.5. Verify `PipelineOrchestrator.initialize()` ([`openhcs/core/orchestrator/orchestrator.py`](openhcs/core/orchestrator/orchestrator.py:1))**
    *   **Action:** Ensure `initialize()` performs all necessary validation for disk paths and sets up the plate correctly. (As per V3 Plan 2.3).

---

## Phase 3: Implement Dual Step/Func Editor (with Commands)

**Objective:** Implement the `DualStepFuncEditorPane` for editing `FuncStep` objects, using Static Reflection and Command Pattern for its internal actions. This pane is shown when `ShowEditStepDialogCommand` updates `TUIState`.

**3.1. Implement `DualStepFuncEditorPane` ([`openhcs/tui/dual_step_func_editor.py`](openhcs/tui/dual_step_func_editor.py:1))**
    *   **Action:** `__init__(self, state: TUIState, func_step_to_edit: FunctionStep)`: Store state, make a working copy of `func_step_to_edit`.
    *   **Action:** Implement its main container and internal menu bar: `[_X_Step_X_] [___Func___] | [save] [close]` (from `tui_final.md`).
        *   Toggle buttons ("Step Settings", "Func Pattern") trigger `SwitchDualEditorViewCommand(view_name)`.
        *   `[save]` button triggers `SaveDualEditorCommand()`. Disabled until changes are made.
        *   `[close]` button triggers `CloseDualEditorCommand()`.
    *   **Action:** Implement "Step Settings" view (`_create_step_settings_view`):
        *   Dynamically generate UI elements (Labels, TextAreas, Dropdowns for enums like `VariableComponents`, `GroupBy`) by introspecting `AbstractStep` parameters.
        *   Populate with values from the working copy of `func_step_to_edit`.
        *   Implement "Load" (`LoadStepParamsCommand`) and "Save As" (`SaveStepParamsCommand`) buttons for `.step` objects (persisting/loading `AbstractStep` parameters via file dialogs).
        *   Track changes to enable/disable the main "Save" button.
    *   **Action:** Implement "Func Pattern" view (`_create_func_pattern_view`):
        *   Adapt logic from the old `FunctionPatternEditor` for displaying and editing the `func` pattern.
        *   Use `FUNC_REGISTRY` and static reflection of function signatures to dynamically generate UI for selecting functions and editing their `kwargs`.
        *   Support list/dictionary patterns, add/delete/move functions within the pattern.
        *   Implement "Load" (`LoadFuncPatternCommand`), "Save As" (`SaveFuncPatternCommand`), and "Edit in Vim" (`EditPatternInVimCommand`) buttons.
        *   Track changes to enable/disable the main "Save" button.
    *   **Action:** `SaveDualEditorCommand.execute()`: Constructs a new `FunctionStep` from UI values from *both* views. Notifies `self.state.notify('step_pattern_saved', {'original_step_id': self.original_func_step.id, 'new_step_definition': new_func_step_dict_or_instance})`.
    *   **Action:** `CloseDualEditorCommand.execute()`: Notifies `self.state.notify('step_editing_cancelled')` or `self.state.notify('step_editing_finished')` which sets `state.editing_step_config = False`.

**3.2. Verify `OpenHCSTUI._get_left_pane` ([`openhcs/tui/tui_architecture.py`](openhcs/tui/tui_architecture.py:1))**
    *   **Action:** Ensure this method correctly displays `DualStepFuncEditorPane` when `self.state.editing_step_config` is true and `self.state.step_to_edit_config` (a `FunctionStep` instance) is set. The `ShowEditStepDialogCommand` (from Phase 1.5) is responsible for setting this state.

---

## Phase 4: Implement Configuration Editors (Global & Plate-Specific, with Commands)

**Objective:** Provide UI for editing global and plate-specific configurations using Static Reflection, with dialog actions handled by Commands.

**4.1. Implement `GlobalSettingsEditorDialog` ([`openhcs/tui/dialogs/global_settings_editor.py`](openhcs/tui/dialogs/global_settings_editor.py:1))**
    *   **Action:** Launched by `ShowGlobalSettingsDialogCommand` (from Phase 1.3).
    *   **Action:** Complete dynamic UI generation in `_build_dialog()` by introspecting `GlobalPipelineConfig` (including nested objects like `VFSConfig`, `PathPlanningConfig`). Use appropriate widgets.
    *   **Action:** "Save" button triggers `SaveGlobalConfigCommand`. Its `execute()` method updates `self.editing_config` from UI, then notifies `self.state.notify('global_config_changed', new_global_config)` and `self.state.notify('global_config_needs_update', new_global_config)` (for launcher).
    *   **Action:** "Cancel" button could trigger a generic `CancelDialogCommand` or be handled locally.

**4.2. Create and Implement `PlateConfigEditorDialog` (New file: `openhcs/tui/dialogs/plate_config_editor.py`)**
    *   **Action:** Launched by `ShowEditPlateConfigDialogCommand` (from Phase 1.4), which passes the selected `PipelineOrchestrator`.
    *   **Action:** `__init__(self, state: TUIState, orchestrator_to_edit: PipelineOrchestrator)`: Works on a copy of `orchestrator_to_edit.config`.
    *   **Action:** Dynamically generate UI by introspecting the orchestrator's config structure (which is a `GlobalPipelineConfig` instance that can be overridden).
    *   **Action:** "Save" button triggers `SavePlateConfigCommand`. Its `execute()` method updates the *actual* `orchestrator_to_edit.config` and notifies `self.state.notify('plate_config_changed', {'plate_id': orchestrator_to_edit.plate_id, 'new_config': ...})`. May also trigger persistence of this config.
    *   **Action:** "Cancel" button.

---

## Phase 5: Complete `async` Propagation and Final Cleanup

**Objective:** Ensure all asynchronous operations and TUI state notifications are correctly implemented.
    *   **Action:** Review all Command `execute()` methods, button handlers, and other methods that perform I/O or interact with `TUIState.notify`. Ensure they are `async def` and use `await` appropriately.
    *   **Action:** UI event handlers (e.g., in `Button(handler=...)`) that trigger async commands should use `get_app().create_background_task(command.execute(...))`.
    *   **Action:** Review `TUIStatusBarLogHandler.emit` for correct async scheduling.
    *   **Action:** Address remaining architectural inconsistencies from V3 Plan 5.2 (e.g., `PlateValidationService.close()`, ensure `container` properties are correctly scoped).

---

## Phase 6: Final Verification

**Objective:** Ensure the refactored TUI is stable and correct.
    *   **6.1. Code Compilation:** As per V3 Plan 6.1.
    *   **6.2. Manual Testing:** As per V3 Plan 6.2, covering all new command-driven flows, the interactive "Add Plate" dialog, `DualStepFuncEditorPane`, and config editors.
    *   **6.3. (Optional) Automated Tests:** As per V3 Plan 6.3. Consider unit tests for individual Command classes.

---

This synthesized plan (V4) provides a detailed roadmap. It respects the phased approach of your V3 plan while integrating the Command Pattern for cleaner action handling and specifying the interactive, VFS-aware browser for adding plates.