# Semantic Matrix Analyzer

An AI-driven tool for analyzing Python codebases that translates natural language conversations about code quality into AST-based (Abstract Syntax Tree) analysis. This tool helps identify refactoring opportunities and assess code quality without requiring users to understand the technical details.

## Key Benefits

- **AI-Driven Analysis**: Have natural conversations with an AI agent about code quality concerns
- **Zero Technical Overhead**: Users don't need to learn special syntax or commands
- **Comprehensive Analysis**: Systematically analyzes entire codebases for quality issues
- **Actionable Insights**: Provides specific, practical recommendations for improvement
- **Continuous Learning**: Builds on previous conversations to deepen understanding

## Technical Features

- **AST-based Analysis**: Analyzes Python code structure using the built-in `ast` module
- **Intent Extraction**: AI extracts intents from natural language conversations
- **Plugin System**: Supports custom plugins for defining intents and patterns
- **Pattern Detection**: Detects specific code patterns using string matching, regex, and AST traversal
- **Matrix Generation**: Creates a matrix correlating components with intents
- **Visualization**: Generates heatmap visualizations of the semantic matrix
- **Reporting**: Produces comprehensive Markdown reports with findings and recommendations

## Installation

1. Clone this repository
2. Install dependencies:
```bash
pip install numpy matplotlib
```

## Usage

### For Users: AI-Assisted Analysis

The Semantic Matrix Analyzer is designed to be used with an AI agent (like Claude) that handles all the technical details for you:

1. **Have a conversation** with the AI agent about your code quality concerns
2. **The AI agent** extracts intents from your conversation
3. **The AI agent** runs the analysis on your codebase
4. **The AI agent** explains the results to you in plain language

You never need to run any commands yourself or understand the technical details. See [AI-Assisted Usage](docs/ai_assisted_usage.md) for a detailed guide.

### For AI Agents: Technical Usage

AI agents can use these commands to analyze codebases based on user conversations:

```bash
# Extract intents from a conversation
python extract_intents.py --text "User's concerns..." --output conversations/intents.json

# Analyze a codebase using extracted intents
python semantic_matrix_analyzer.py analyze --project-dir /path/to/project --config config.json

# Generate a visualization and report
# (These are automatically generated by the analyze command)
```

See [Creating Plugins](docs/creating_plugins.md) for information on extending the tool with custom plugins.

### Technical Reference (For AI Agents)

The following command-line options are provided for AI agents to use when analyzing codebases. Users should not need to use these commands directly.

#### `semantic_matrix_analyzer.py analyze` Command

- `--config`: Path to configuration file (JSON)
- `--project-dir`: Path to project directory (default: current directory)
- `--components`: Comma-separated list of components to analyze
- `--intents`: Comma-separated list of intents to analyze
- `--output-dir`: Directory to save output files (default: current directory)
- `--output-prefix`: Prefix for output files (default: "semantic_matrix")
- `--format`: Output format for visualization (png, svg, pdf) (default: png)

#### `semantic_matrix_analyzer.py generate-config` Command

- `--output`: Output file path (default: "semantic_matrix_config.json")

#### `extract_intents.py` Command

- `--input`: Path to conversation text file
- `--text`: Conversation text (alternative to --input)
- `--output`: Path to output JSON file
- `--append`: Append to existing file instead of overwriting

### Configuration File

The configuration file is a JSON file with the following structure:

```json
{
  "project_dir": ".",
  "components": {
    "Component1": "path/to/component1.py",
    "Component2": "path/to/component2.py"
  },
  "intents": [
    "Intent1",
    "Intent2"
  ],
  "output": {
    "directory": ".",
    "prefix": "semantic_matrix",
    "format": "png"
  }
}
```

- `project_dir`: Root directory of the project
- `components`: Dictionary mapping component names to file paths (relative to project_dir)
  - If a value is `null`, the tool will try to infer the file path
- `intents`: List of intents to analyze
- `output`: Output configuration
  - `directory`: Directory to save output files
  - `prefix`: Prefix for output files
  - `format`: Output format for visualization (png, svg, pdf)

## Output Files

The tool generates the following output files:

- `{prefix}.{format}`: Visualization of the semantic matrix
- `{prefix}_report.md`: Comprehensive report with findings and recommendations
- `{prefix}_data.json`: Analysis data in JSON format for further processing

## Example Workflow

### User-AI Conversation

```
User: "I'm concerned about our error handling practices. Can you check if we're properly catching and logging exceptions?"

AI: "I'll analyze your codebase for proper error handling practices. Let me check for try-except blocks, specific exception types, and logging patterns."

[AI runs analysis behind the scenes]

AI: "I've analyzed your codebase and found that 70% of your functions have proper error handling. However, there are some issues:

1. In the authentication module, 5 functions catch generic exceptions instead of specific ones
2. The payment processing code has proper try-except blocks but doesn't log the exceptions
3. The user management module has good practices overall with specific exceptions and proper logging

Would you like me to show you the specific problematic files?"

User: "Yes, show me the authentication module issues first."

[AI provides specific examples and recommendations]
```

### Behind the Scenes (What the AI Does)

1. The AI extracts intents from the conversation:
   - Error handling practices
   - Specific exception catching
   - Exception logging

2. The AI runs the analysis:
   ```bash
   python extract_intents.py --text "..." --output conversations/error_handling.json
   python semantic_matrix_analyzer.py analyze --project-dir ./user_codebase --config error_handling_config.json
   ```

3. The AI interprets the results:
   - `./output/semantic_matrix.png`: Visualization of the semantic matrix
   - `./output/semantic_matrix_report.md`: Comprehensive report
   - `./output/semantic_matrix_data.json`: Analysis data in JSON format

## Extending the Tool

### Creating Custom Intent Plugins

You can create custom intent plugins by subclassing the `IntentPlugin` class:

```python
# plugins/my_custom_plugin.py
from semantic_matrix_analyzer import IntentPlugin, Intent

class MyCustomPlugin(IntentPlugin):
    @staticmethod
    def get_intents() -> List[Intent]:
        intents = []

        # Create custom intents
        my_intent = Intent(
            name="My Custom Intent",
            description="Description of my custom intent"
        )

        # Add patterns to the intent
        my_intent.add_string_pattern(
            name="pattern1",
            description="Description of pattern1",
            pattern="pattern1",
            weight=1.0
        )

        intents.append(my_intent)
        return intents
```

### Defining Intents in Conversations

You can define intents in conversations using a specific format that can be extracted by the `extract_intents.py` script:

```
Intent: Clean Code
Pattern: meaningful name
Type: string
Description: Using meaningful variable and function names

Pattern: def\s+[a-zA-Z_][a-zA-Z0-9_]*\s*\([^)]*\)\s*:\s*(?:\s*\"\"\"[^\"]*\"\"\"\s*)?(?:[^\n]*\n){1,10}\s*return
Type: regex
Description: Writing small, focused functions
```

### Adding New Analysis Rules

You can add new analysis rules by modifying the `analyze_component` method in the `SemanticMatrixBuilder` class. For example, to add a rule that checks for direct file I/O:

```python
# Check for direct file I/O
if "open(" in source_code or "with open" in source_code:
    analysis.issues.append({
        "type": "direct_file_io",
        "message": f"Component '{component}' uses direct file I/O instead of VFS"
    })
```

### Adding New Pattern Types

You can add new pattern types by extending the `IntentPattern` class and updating the `IntentDetector._check_pattern` method:

```python
# Add a new pattern type
def _check_new_pattern_type(self, pattern: Any, analysis: ComponentAnalysis) -> float:
    # Implement your pattern checking logic here
    return 0.0  # Return a score between 0.0 and 1.0

# Update the _check_pattern method
def _check_pattern(self, pattern: IntentPattern, analysis: ComponentAnalysis) -> float:
    if pattern.pattern_type == "new_type":
        return self._check_new_pattern_type(pattern.pattern, analysis)
    # ... existing pattern types ...
```

### Custom Component Path Resolution

You can customize how component paths are resolved by modifying the `get_file_path_for_component` method in the `SemanticMatrixBuilder` class.

## License

This project is licensed under the MIT License - see the LICENSE file for details.
